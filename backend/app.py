from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_cors import CORS
from datetime import datetime
from flask import Flask, request, jsonify
from sqlalchemy import LargeBinary
import base64
import os
import psycopg2
import re


# Define the database URI for PostgreSQL
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://postgres:root@localhost/property_management'
db = SQLAlchemy(app)
CORS(app)
migrate = Migrate(app, db)


class Property(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    property_name = db.Column(db.String(100), nullable=False)
    amount = db.Column(db.Float, default=0.0)
    description = db.Column(db.String(100), nullable=False)
    category = db.Column(db.String(100), nullable=True)
    location = db.Column(db.String(100), nullable=True)
    attachments = db.Column(db.LargeBinary, nullable=True)
    created_on = db.Column(db.DateTime, default=datetime.utcnow)

    def __init__(self, property_name, amount, description, category, location, attachments, featured_property=False):
        self.property_name = property_name
        self.amount = amount
        self.description = description
        self.category = category
        self.location = location
        self.attachments = attachments

    def to_dict(self):
        return {
            'id': self.id,
            'property_name': self.property_name,
            'description': self.description,
            'amount': self.amount,
            'category': self.category,
            'location': self.location,
            'created_on': self.created_on.isoformat(),
        }

    # Routes


@app.route('/', methods=['GET'])
def index():
    properties = Property.query.order_by(Property.id.asc()).all()
    property_list = [{
        'property_name': property.property_name,
        'amount': property.amount,
        'description': property.description
    } for property in properties]
    print("property data", property_list)
    return render_template('homepage.html', properties=property_list)


@app.route('/properties', methods=['POST'])
def create_property():
    data = request.json
    property_name = data.get('property')
    description = data.get('description')
    location = data.get('location')
    category = data.get('category')
    amount = data.get('value')
    attachments = data['attachments']

    if 'attachments' in data:
        for attachment in data['attachments']:
            home_directory = os.path.expanduser("~")
            image_path = os.path.join(
                home_directory, 'Downloads', attachment['path'])
            with open(image_path, 'rb') as file:
                image_data = file.read()
                print('Image data type:', type(image_data))
                # Encode binary data to Base64
                encoded_image_data = base64.b64encode(
                    image_data).decode('utf-8')
                # Decode Base64 encoded data back to binary
                decoded_image_data = base64.b64decode(encoded_image_data)
                # Insert each attachment separately
                new_property = Property(property_name=property_name,
                                        amount=amount,
                                        description=description,
                                        category=category,
                                        location=location,
                                        attachments=decoded_image_data)
                db.session.add(new_property)
        db.session.commit()

    return jsonify((new_property)), 201


@app.route('/properties', methods=['GET'])
def get_properties():
    properties = Property.query.order_by(Property.id.asc()).all()
    property_list = [property.to_dict() for property in properties]
    return jsonify({'properties': property_list})


@app.route('/properties/<property_name>', methods=['GET'])
def get_property_single(property_name):
    print('propersssssss', property_name)
    properties = Property.query.filter_by(property_name=property_name).one()
    print('-->>>>>>>>>>>>', properties)

    formatted_property = format_event(properties)
    return jsonify({'properties': formatted_property})


@app.route('/properties/<id>', methods=['DELETE'])
def delete_property(id):
    print('propersssssss', id)
    property = Property.query.filter_by(id=id).first()
    db.session.delete(property)
    db.session.commit()

    return f'Deleted {property}'


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('property', sa.Column(
        'category', sa.String(length=100), nullable=True))
    # ### end Alembic commands ###


@app.route('/properties/<kwargs>', methods=['PUT'])
def update_property(kwargs):
    try:
        print("-->>>>>>>>>", kwargs)
        return
        property_id = int(id)
        # Safely get the 'description' value from JSON data
        description = request.json.get('description')
        if description is not None:
            # Use .first() to get the first matching record
            property = Property.query.filter_by(id=property_id).first()
            if property:
                property.description = description
                property.created_on = datetime.utcnow()
                db.session.commit()
                return f"Property with ID {property_id} updated successfully!"
            else:
                return f"Property with ID {property_id} not found.", 404
        else:
            return "Description field is missing in the request data.", 400
    except Exception as e:
        return f"An error occurred: {str(e)}", 500

    return {'Property': format_event(property.one())}


if __name__ == '__main__':
    app.run()
